---
// Brain Week 2026 - Landing Page
---

<html lang="pl">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width" />
    <meta name="description" content="Brain Week 2026 - Uniwersytet w Białymstoku, 9-13 marca. Biologiczne i sztuczne sieci neuronowe." />
    <title>Brain Week 2026 | UwB</title>
  </head>
  <body>
    <!-- Network canvas -->
    <canvas id="network"></canvas>
    
    <!-- Brain image -->
    <div class="brain-container">
      <img src="/brain-lateral.png" alt="" class="brain-image" />
    </div>
    
    <!-- Content -->
    <main>
      <h1>Brain Week</h1>
      <p class="year">2026</p>
      <p class="subtitle">biologiczne i sztuczne sieci neuronowe</p>
      <p class="dates">9–13 marca</p>
      <p class="location">Uniwersytet w Białymstoku</p>
      
      <div class="cta">
        <a href="#program" class="button">Program</a>
        <a href="#prelegenci" class="button button-secondary">Prelegenci</a>
      </div>
    </main>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html, body {
        height: 100%;
        overflow-x: hidden;
      }

      body {
        background: linear-gradient(180deg, 
          #0a0a0f 0%, 
          #0d0d1a 30%,
          #111128 60%,
          #0a0a0f 100%
        );
        background-attachment: fixed;
        color: #e2e8f0;
        font-family: 'Segoe UI', system-ui, sans-serif;
        min-height: 100vh;
        position: relative;
      }

      #network {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
      }

.brain-container {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: min(75vw, 550px);
  z-index: 2;
  pointer-events: none;
}

      @keyframes brainFadeIn {
        0% {
          opacity: 0;
          filter: blur(20px);
          transform: translate(-50%, -50%) scale(0.9);
        }
        100% {
          opacity: 1;
          filter: blur(0);
          transform: translate(-50%, -50%) scale(1);
        }
      }

		.brain-image {
		width: 100%;
		height: auto;
		opacity: 0.5;
		}

      main {
        position: relative;
        z-index: 3;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 2rem;
        text-align: center;
      }

      h1 {
        font-size: clamp(2.5rem, 8vw, 5rem);
        font-weight: 300;
        letter-spacing: 0.2em;
        text-transform: uppercase;
        background: linear-gradient(135deg, #e2e8f0 0%, #a78bfa 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        opacity: 0;
        animation: fadeUp 1.5s ease-out 0.8s forwards;
      }

      .year {
        font-size: clamp(3rem, 10vw, 6rem);
        font-weight: 100;
        color: #8b5cf6;
        letter-spacing: 0.4em;
        margin: -0.5rem 0 0.8rem;
        padding-left: 0.4em;
        opacity: 0;
        animation: fadeUp 1.5s ease-out 1s forwards;
      }

      .subtitle {
        font-size: 0.9rem;
        color: #64748b;
        letter-spacing: 0.2em;
        margin-bottom: 1.5rem;
        text-transform: lowercase;
        opacity: 0;
        animation: fadeUp 1.5s ease-out 1.2s forwards;
      }

      .dates {
        font-size: 1.2rem;
        color: #94a3b8;
        letter-spacing: 0.2em;
        opacity: 0;
        animation: fadeUp 1.5s ease-out 1.4s forwards;
      }

      .location {
        font-size: 1rem;
        color: #64748b;
        letter-spacing: 0.1em;
        margin-bottom: 2.5rem;
        opacity: 0;
        animation: fadeUp 1.5s ease-out 1.5s forwards;
      }

      .cta {
        display: flex;
        gap: 1rem;
        justify-content: center;
        flex-wrap: wrap;
        opacity: 0;
        animation: fadeUp 1.5s ease-out 1.7s forwards;
      }

      @keyframes fadeUp {
        0% {
          opacity: 0;
          transform: translateY(20px);
        }
        100% {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .button {
        padding: 1rem 2.5rem;
        border-radius: 4px;
        text-decoration: none;
        font-size: 0.85rem;
        letter-spacing: 0.15em;
        text-transform: uppercase;
        transition: all 0.3s ease;
        background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
        color: white;
        border: 1px solid transparent;
      }

      .button:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 30px rgba(139, 92, 246, 0.3);
      }

      .button-secondary {
        background: transparent;
        border: 1px solid #8b5cf6;
        color: #a78bfa;
      }

      .button-secondary:hover {
        background: rgba(139, 92, 246, 0.1);
      }
    </style>

    <script>
      const canvas = document.getElementById('network');
      const ctx = canvas.getContext('2d');
      
      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      resize();
      window.addEventListener('resize', resize);
      
      // Pareto distribution
      function pareto(xMin, alpha) {
        const u = Math.random();
        return xMin / Math.pow(u, 1 / alpha);
      }
      
      // Node class
      class Node {
        constructor() {
          this.spawn();
        }
        
        spawn() {
          this.x = Math.random() * canvas.width;
          this.y = Math.random() * canvas.height;
          this.radius = Math.random() * 1.5 + 1;
          this.baseOpacity = Math.random() * 0.3 + 0.5;
          this.opacity = 0;
          
          const speed = 0.08 + Math.random() * 0.12;
          const angle = Math.random() * Math.PI * 2;
          this.vx = Math.cos(angle) * speed;
          this.vy = Math.sin(angle) * speed;
          
          this.maxLife = Math.floor((5 + Math.random() * 15) * 60);
          this.life = this.maxLife;
          this.maxConnDist = Math.min(pareto(40, 2.5), 250);
          
          this.pulsePhase = Math.random() * Math.PI * 2;
          this.pulseSpeed = 0.015 + Math.random() * 0.01;
        }
        
        update(nodes) {
          const attractionRange = 150;
          const attractionStrength = 0.00012;
          
          for (const other of nodes) {
            if (other === this) continue;
            
            const dx = other.x - this.x;
            const dy = other.y - this.y;
            const dist = Math.hypot(dx, dy);
            
            if (dist < attractionRange && dist > 10) {
              const force = attractionStrength * (1 - dist / attractionRange);
              this.vx += (dx / dist) * force;
              this.vy += (dy / dist) * force;
            }
            
            if (dist < 30 && dist > 0) {
              const repel = 0.0003 * (1 - dist / 30);
              this.vx -= (dx / dist) * repel;
              this.vy -= (dy / dist) * repel;
            }
          }
          
          this.x += this.vx;
          this.y += this.vy;
          
          this.vx *= 0.998;
          this.vy *= 0.998;
          
          this.vx += (Math.random() - 0.5) * 0.003;
          this.vy += (Math.random() - 0.5) * 0.003;
          
          const speed = Math.hypot(this.vx, this.vy);
          const maxSpeed = 0.4;
          const minSpeed = 0.03;
          if (speed > maxSpeed) {
            this.vx = (this.vx / speed) * maxSpeed;
            this.vy = (this.vy / speed) * maxSpeed;
          } else if (speed < minSpeed && speed > 0) {
            this.vx = (this.vx / speed) * minSpeed;
            this.vy = (this.vy / speed) * minSpeed;
          }
          
          const margin = 50;
          const pushStrength = 0.0005;
          if (this.x < margin) this.vx += pushStrength * (margin - this.x);
          if (this.x > canvas.width - margin) this.vx -= pushStrength * (this.x - (canvas.width - margin));
          if (this.y < margin) this.vy += pushStrength * (margin - this.y);
          if (this.y > canvas.height - margin) this.vy -= pushStrength * (this.y - (canvas.height - margin));
          
          const fadeInEnd = this.maxLife * 0.9;
          const fadeOutStart = this.maxLife * 0.15;
          
          if (this.life > fadeInEnd) {
            this.opacity = Math.min(this.opacity + 0.02, this.baseOpacity);
          } else if (this.life < fadeOutStart) {
            this.opacity = Math.max(this.opacity - 0.015, 0);
          }
          
          this.pulsePhase += this.pulseSpeed;
          this.life--;
          
          if (this.life <= 0) {
            this.spawn();
          }
        }
        
        draw() {
          if (this.opacity < 0.01) return;
          
          const pulse = Math.sin(this.pulsePhase) * 0.15 + 0.9;
          const r = this.radius * pulse;
          
          ctx.beginPath();
          ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(180, 160, 255, ${this.opacity * pulse})`;
          ctx.fill();
          
          ctx.beginPath();
          ctx.arc(this.x, this.y, r * 3, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(139, 92, 246, ${this.opacity * 0.12})`;
          ctx.fill();
        }
      }
      
      // Signal class
      class Signal {
        constructor(nodeA, nodeB) {
          this.nodeA = nodeA;
          this.nodeB = nodeB;
          this.pos = 0;
          this.speed = 0.003 + Math.random() * 0.005;
          this.direction = Math.random() > 0.5 ? 1 : -1;
          if (this.direction < 0) this.pos = 1;
        }
        
        update() {
          this.pos += this.speed * this.direction;
          return this.pos >= 0 && this.pos <= 1;
        }
        
        draw(opacity) {
          const x = this.nodeA.x + (this.nodeB.x - this.nodeA.x) * this.pos;
          const y = this.nodeA.y + (this.nodeB.y - this.nodeA.y) * this.pos;
          
          ctx.beginPath();
          ctx.arc(x, y, 2, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(220, 200, 255, ${opacity * 0.8})`;
          ctx.fill();
          
          ctx.beginPath();
          ctx.arc(x, y, 5, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(180, 160, 255, ${opacity * 0.25})`;
          ctx.fill();
        }
      }
      
      // Initialize
      const area = window.innerWidth * window.innerHeight;
      const nodeCount = Math.floor(area / 5500);
      
      const nodes = [];
      for (let i = 0; i < nodeCount; i++) {
        nodes.push(new Node());
      }
      
      let signals = [];
      
      // Animation loop
      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        nodes.forEach(node => node.update(nodes));
        
        // Draw connections
        for (let i = 0; i < nodes.length; i++) {
          for (let j = i + 1; j < nodes.length; j++) {
            const a = nodes[i];
            const b = nodes[j];
            const dist = Math.hypot(a.x - b.x, a.y - b.y);
            
            const maxDist = Math.min(a.maxConnDist, b.maxConnDist);
            
            if (dist < maxDist) {
              const strength = 1 - (dist / maxDist);
              const opacity = strength * Math.min(a.opacity, b.opacity) * 0.45;
              
              if (opacity > 0.01) {
                ctx.beginPath();
                ctx.moveTo(a.x, a.y);
                ctx.lineTo(b.x, b.y);
                ctx.strokeStyle = `rgba(139, 92, 246, ${opacity})`;
                ctx.lineWidth = strength * 1.2;
                ctx.stroke();
                
                if (Math.random() < 0.0003 * strength) {
                  signals.push(new Signal(a, b));
                }
              }
            }
          }
        }
        
        // Update and draw signals
        signals = signals.filter(signal => {
          const maxDist = Math.min(signal.nodeA.maxConnDist, signal.nodeB.maxConnDist);
          const dist = Math.hypot(
            signal.nodeA.x - signal.nodeB.x,
            signal.nodeA.y - signal.nodeB.y
          );
          if (dist > maxDist) return false;
          
          const alive = signal.update();
          if (alive) {
            const strength = 1 - (dist / maxDist);
            const opacity = strength * Math.min(signal.nodeA.opacity, signal.nodeB.opacity);
            signal.draw(opacity);
          }
          return alive;
        });
        
        // Draw nodes
        nodes.forEach(node => node.draw());
        
        requestAnimationFrame(animate);
      }
      
      animate();
    </script>
  </body>
</html>
