---
// CyberWeek 2026 - Landing Page
---

<html lang="pl">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/brain-week/favicon.svg" />
    <meta name="viewport" content="width=device-width" />
    <meta name="description" content="CyberWeek 2026 - Uniwersytet w Białymstoku, 9-13 marca. Biologiczne i sztuczne sieci neuronowe." />
    <title>CyberWeek 2026 | UwB</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&family=Poppins:wght@300;400;600;700&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet" />
  </head>
  <body>
    <!-- Network canvas -->
    <canvas id="network"></canvas>
    
    <!-- Brain image -->
    <div class="brain-container">
      <img src="/brain-week/brain-lateral.png" alt="" class="brain-image" />
    </div>
    
    <!-- Content -->
    <main>
      <section class="hero">
        <h1>CyberWeek</h1>
        <p class="year">2026</p>
        <p class="subtitle">Dowiedz Się Jak Myśli Mózg</p>
        <p class="dates">9–13 marca</p>
        <p class="location">BIAŁYSTOK</p>
        
        <div class="cta">
          <a href="/brain-week/program" class="button">Program</a>
          <a href="/brain-week/prelegenci" class="button button-secondary">Prelegenci</a>
        </div>
      </section>

      <section class="about">
        <h2>O wydarzeniu</h2>
        <p class="about-text">
          CyberWeek to białostocka odsłona międzynarodowego <strong>Brain Awareness Week</strong> – 
          ogólnoświatowej inicjatywy popularyzującej wiedzę o mózgu i układzie nerwowym. 
          Przez pięć dni naukowcy, praktycy i entuzjaści spotykają się, by rozmawiać o tym, 
          jak działa nasz mózg – i jak działają jego sztuczne odpowiedniki.
        </p>
        <p class="about-text">
          Wykłady, warsztaty i dyskusje prowadzone przez badaczy z Uniwersytetu w Białymstoku 
          i zaproszonych gości. Tematyka: od neurobiologii przez kognitywistykę po sztuczną inteligencję.
        </p>
      </section>

      <section class="faq">
        <h2>FAQ</h2>
        <div class="faq-grid">
          <div class="faq-item">
            <h3>Czy wstęp jest płatny?</h3>
            <p>Nie. Wszystkie wydarzenia CyberWeek są <strong>bezpłatne</strong> i otwarte dla każdego.</p>
          </div>
          <div class="faq-item">
            <h3>Czy muszę się rejestrować?</h3>
            <p>Nie ma obowiązkowej rejestracji. Przyjdź i weź udział.</p>
          </div>
          <div class="faq-item">
            <h3>Dla kogo jest to wydarzenie?</h3>
            <p>Dla wszystkich zainteresowanych – studentów, uczniów, profesjonalistów i hobbystów. Nie wymagamy specjalistycznej wiedzy.</p>
          </div>
          <div class="faq-item">
            <h3>Gdzie odbywają się wydarzenia?</h3>
            <p>Na kampusie Uniwersytetu w Białymstoku. Szczegóły lokalizacji w <a href="/brain-week/program">programie</a>.</p>
          </div>
        </div>
      </section>
    </main>

    <style>
      :root {
        /* === PALETTE === */
        --bg-dark: #18181a;
        --bg-mid: #1a1a1f;
        --bg-deep: #1c1c24;
        
        --text-light: #efdee8;
        --text-mid: #dddddd;
        --text-dim: #919598;
        
        --accent-violet: #6e27e1;
        --accent-pink: #f287c8;
        --accent-cyan: #40d0d5;
        --accent-grad-start: #0900d6;
        --accent-grad-end: #ff8cd1;
        
        /* === FONTS === */
        /* Replace 'Orbitron' with 'RQND Pro' when self-hosted */
        --font-title: 'Orbitron', sans-serif;
        --font-body: 'Poppins', sans-serif;
        --font-mono: 'Roboto Mono', monospace;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html, body {
        height: 100%;
        overflow-x: hidden;
      }

      body {
        background: linear-gradient(180deg, 
          var(--bg-dark) 0%, 
          var(--bg-mid) 30%,
          var(--bg-deep) 60%,
          var(--bg-dark) 100%
        );
        background-attachment: fixed;
        color: var(--text-light);
        font-family: var(--font-body);
        min-height: 100vh;
        position: relative;
      }

      #network {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
      }

      .brain-container {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: min(75vw, 550px);
        z-index: 2;
        pointer-events: none;
        animation: brainFadeIn 3s ease-out forwards;
      }

      @keyframes brainFadeIn {
        0% {
          opacity: 0;
          filter: blur(15px);
        }
        100% {
          opacity: 1;
          filter: blur(0);
        }
      }

      .brain-image {
        width: 100%;
        height: auto;
        mix-blend-mode: screen;
        opacity: 0.2;
        filter: hue-rotate(260deg) saturate(0.8) brightness(1.2);
        mask-image: radial-gradient(ellipse 80% 80% at 50% 50%, black 30%, transparent 70%);
        -webkit-mask-image: radial-gradient(ellipse 80% 80% at 50% 50%, black 30%, transparent 70%);
      }

      main {
        position: relative;
        z-index: 3;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 2rem;
      }

      .hero {
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
      }

      h1 {
        font-family: var(--font-title);
        font-size: clamp(2.5rem, 8vw, 5rem);
        font-weight: 400;
        letter-spacing: 0;
        line-height: 1.5;
        text-transform: uppercase;
        background: linear-gradient(135deg, var(--text-light) 0%, var(--accent-pink) 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        opacity: 0;
        animation: fadeUp 1.5s ease-out 0.8s forwards;
      }

      .year {
        font-family: var(--font-title);
        font-size: clamp(3rem, 10vw, 6rem);
        font-weight: 400;
        color: var(--accent-violet);
        letter-spacing: 0.4em;
        margin: -0.5rem 0 0.8rem;
        padding-left: 0.4em;
        opacity: 0;
        animation: fadeUp 1.5s ease-out 1s forwards;
      }

      .subtitle {
        font-family: var(--font-body);
        font-size: 0.95rem;
        font-weight: 300;
        color: var(--text-light);
        letter-spacing: 0.2em;
        margin-bottom: 1.5rem;
        opacity: 0;
        animation: fadeUp 1.5s ease-out 1.2s forwards;
      }

      .dates {
        font-family: var(--font-mono);
        font-size: 1.2rem;
        font-weight: 500;
        color: var(--accent-cyan);
        letter-spacing: 0.2em;
        opacity: 0;
        animation: fadeUp 1.5s ease-out 1.4s forwards;
      }

      .location {
        font-family: var(--font-body);
        font-size: 1.3rem;
        font-weight: 600;
        color: var(--text-light);
        letter-spacing: 0.2em;
        margin-top: 0.8rem;
        margin-bottom: 2.5rem;
        opacity: 0;
        animation: fadeUp 1.5s ease-out 1.5s forwards;
      }

      .cta {
        display: flex;
        gap: 1rem;
        justify-content: center;
        flex-wrap: wrap;
        opacity: 0;
        animation: fadeUp 1.5s ease-out 1.7s forwards;
      }

      @keyframes fadeUp {
        0% {
          opacity: 0;
          transform: translateY(20px);
        }
        100% {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .button {
        font-family: var(--font-body);
        padding: 1rem 2.5rem;
        border-radius: 4px;
        text-decoration: none;
        font-size: 0.85rem;
        font-weight: 600;
        letter-spacing: 0.15em;
        text-transform: uppercase;
        transition: all 0.3s ease;
        background: linear-gradient(135deg, var(--accent-violet) 0%, var(--accent-grad-start) 100%);
        color: white;
        border: 1px solid transparent;
      }

      .button:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 30px rgba(110, 39, 225, 0.3);
      }

      .button-secondary {
        background: transparent;
        border: 1px solid var(--accent-violet);
        color: white;
      }

      .button-secondary:hover {
        background: rgba(110, 39, 225, 0.1);
      }

      /* About & FAQ sections */
      .about, .faq {
        max-width: 800px;
        width: 100%;
        padding: 4rem 2rem;
        text-align: center;
      }

      .about h2, .faq h2 {
        font-family: var(--font-title);
        font-size: 1.5rem;
        font-weight: 400;
        color: var(--accent-cyan);
        letter-spacing: 0.1em;
        text-transform: uppercase;
        margin-bottom: 2rem;
      }

      .about-text {
        font-size: 1rem;
        font-weight: 300;
        line-height: 1.8;
        color: var(--text-mid);
        margin-bottom: 1.5rem;
      }

      .about-text strong {
        color: var(--text-light);
        font-weight: 600;
      }

      .faq-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 2rem;
        text-align: left;
      }

      .faq-item h3 {
        font-family: var(--font-body);
        font-size: 1rem;
        font-weight: 600;
        color: var(--accent-pink);
        margin-bottom: 0.5rem;
      }

      .faq-item p {
        font-size: 0.9rem;
        font-weight: 300;
        line-height: 1.6;
        color: var(--text-dim);
      }

      .faq-item p strong {
        color: var(--text-light);
        font-weight: 600;
      }

      .faq-item a {
        color: var(--accent-cyan);
        text-decoration: none;
      }

      .faq-item a:hover {
        text-decoration: underline;
      }
    </style>

    <script>
      const canvas = document.getElementById('network');
      const ctx = canvas.getContext('2d');
      
      let centerX, centerY;
      
      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        centerX = canvas.width / 2;
        centerY = canvas.height / 2;
      }
      
      resize();
      window.addEventListener('resize', resize);
      
      function pareto(min, alpha) {
        const u = Math.random();
        return min / Math.pow(u, 1 / alpha);
      }
      
      // Three node colors
      const nodeColors = [
        { r: 110, g: 39, b: 225 },   // violet
        { r: 64, g: 208, b: 213 },   // cyan
        { r: 242, g: 135, b: 200 }   // pink
      ];
      
      function pickColor() {
        const rand = Math.random();
        if (rand < 0.55) return nodeColors[0];      // 55% violet
        if (rand < 0.80) return nodeColors[1];      // 25% cyan
        return nodeColors[2];                        // 20% pink
      }
      
      class Node {
        constructor() {
          this.connectedNodes = new Set();
          this.spawn();
        }
        
        spawn() {
          this.x = Math.random() * canvas.width;
          this.y = Math.random() * canvas.height;
          this.color = pickColor();
          this.radius = Math.random() * 1.5 + 1;
          this.baseOpacity = Math.random() * 0.3 + 0.5;
          this.opacity = 0;
          
          // Variable base speed
          if (Math.random() < 0.05) {
            this.baseSpeed = 1.2 + Math.random() * 0.4;
          } else {
            this.baseSpeed = 0.05 + Math.random() * 0.35;
          }
          this.currentSpeed = this.baseSpeed;
          this.targetSpeed = this.baseSpeed;
          
          const angle = Math.random() * Math.PI * 2;
          this.vx = Math.cos(angle) * this.currentSpeed;
          this.vy = Math.sin(angle) * this.currentSpeed;
          
          this.maxLife = Math.floor((5 + Math.random() * 15) * 60);
          this.life = this.maxLife;
          this.maxConnDist = Math.min(pareto(50, 1.5), 450);
          
          this.pulsePhase = Math.random() * Math.PI * 2;
          this.pulseSpeed = 0.015 + Math.random() * 0.01;
          
          this.seeksCenter = false;
          this.connectedNodes.clear();
        }
        
        connectTo(other) {
          this.connectedNodes.add(other);
          this.seeksCenter = true;
        }
        
        update(nodes) {
          if (this.connectedNodes.size > 0) {
            let maxSpeedInGraph = this.baseSpeed;
            
            for (const other of this.connectedNodes) {
              if (other.baseSpeed > maxSpeedInGraph) {
                maxSpeedInGraph = other.baseSpeed;
              }
            }
            
            this.targetSpeed = maxSpeedInGraph;
            this.currentSpeed += (this.targetSpeed - this.currentSpeed) * 0.02;
          }
          
          if (this.seeksCenter) {
            const dx = centerX - this.x;
            const dy = centerY - this.y;
            const dist = Math.hypot(dx, dy);
            
            if (dist > 5) {
              const targetVx = (dx / dist) * this.currentSpeed;
              const targetVy = (dy / dist) * this.currentSpeed;
              this.vx += (targetVx - this.vx) * 0.025;
              this.vy += (targetVy - this.vy) * 0.025;
            }
            
            if (dist < 80) {
              this.opacity = Math.max(this.opacity - 0.025, 0);
              if (this.opacity <= 0) {
                this.spawn();
                return;
              }
            }
          } else {
            for (const other of nodes) {
              if (other === this) continue;
              
              const dx = other.x - this.x;
              const dy = other.y - this.y;
              const dist = Math.hypot(dx, dy);
              
              if (dist < 120 && dist > 10) {
                const force = 0.00008 * (1 - dist / 120);
                this.vx += (dx / dist) * force;
                this.vy += (dy / dist) * force;
              }
              
              if (dist < 25 && dist > 0) {
                const repel = 0.0002 * (1 - dist / 25);
                this.vx -= (dx / dist) * repel;
                this.vy -= (dy / dist) * repel;
              }
            }
            
            const margin = 50;
            const pushStrength = 0.0004;
            if (this.x < margin) this.vx += pushStrength * (margin - this.x);
            if (this.x > canvas.width - margin) this.vx -= pushStrength * (this.x - (canvas.width - margin));
            if (this.y < margin) this.vy += pushStrength * (margin - this.y);
            if (this.y > canvas.height - margin) this.vy -= pushStrength * (this.y - (canvas.height - margin));
          }
          
          this.x += this.vx;
          this.y += this.vy;
          
          const speed = Math.hypot(this.vx, this.vy);
          if (speed > 0.01) {
            const targetMagnitude = this.seeksCenter ? this.currentSpeed : this.baseSpeed;
            this.vx = (this.vx / speed) * targetMagnitude;
            this.vy = (this.vy / speed) * targetMagnitude;
          }
          
          const driftAngle = Math.random() * Math.PI * 2;
          this.vx += Math.cos(driftAngle) * 0.001;
          this.vy += Math.sin(driftAngle) * 0.001;
          
          const fadeInEnd = this.maxLife * 0.9;
          const fadeOutStart = this.maxLife * 0.15;
          
          if (!this.seeksCenter || Math.hypot(centerX - this.x, centerY - this.y) >= 80) {
            if (this.life > fadeInEnd) {
              this.opacity = Math.min(this.opacity + 0.025, this.baseOpacity);
            } else if (this.life < fadeOutStart) {
              this.opacity = Math.max(this.opacity - 0.015, 0);
            }
          }
          
          this.pulsePhase += this.pulseSpeed;
          this.life--;
          
          if (this.life <= 0) {
            this.spawn();
          }
        }
        
        draw() {
          if (this.opacity < 0.01) return;
          
          const pulse = Math.sin(this.pulsePhase) * 0.15 + 0.9;
          const r = this.radius * pulse;
          const c = this.color;
          
          ctx.beginPath();
          ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(${c.r}, ${c.g}, ${c.b}, ${this.opacity * pulse})`;
          ctx.fill();
          
          ctx.beginPath();
          ctx.arc(this.x, this.y, r * 3, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(${c.r}, ${c.g}, ${c.b}, ${this.opacity * 0.12})`;
          ctx.fill();
        }
      }
      
      class Signal {
        constructor(nodeA, nodeB) {
          this.nodeA = nodeA;
          this.nodeB = nodeB;
          this.pos = 0;
          this.speed = 0.004 + Math.random() * 0.006;
          this.direction = Math.random() > 0.5 ? 1 : -1;
          if (this.direction < 0) this.pos = 1;
        }
        
        update() {
          this.pos += this.speed * this.direction;
          return this.pos >= 0 && this.pos <= 1;
        }
        
        draw(opacity) {
          const x = this.nodeA.x + (this.nodeB.x - this.nodeA.x) * this.pos;
          const y = this.nodeA.y + (this.nodeB.y - this.nodeA.y) * this.pos;
          
          // Signals in pink
          ctx.beginPath();
          ctx.arc(x, y, 2, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(242, 135, 200, ${opacity * 0.8})`;
          ctx.fill();
          
          ctx.beginPath();
          ctx.arc(x, y, 5, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(242, 135, 200, ${opacity * 0.25})`;
          ctx.fill();
        }
      }
      
      const area = window.innerWidth * window.innerHeight;
      const nodeCount = Math.floor(area / 12000);
      
      const nodes = [];
      for (let i = 0; i < nodeCount; i++) {
        nodes.push(new Node());
      }
      
      let signals = [];
      
      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        nodes.forEach(node => node.update(nodes));
        
        for (let i = 0; i < nodes.length; i++) {
          for (let j = i + 1; j < nodes.length; j++) {
            const a = nodes[i];
            const b = nodes[j];
            const dist = Math.hypot(a.x - b.x, a.y - b.y);
            
            const maxDist = Math.min(a.maxConnDist, b.maxConnDist);
            
            if (dist < maxDist) {
              const strength = 1 - (dist / maxDist);
              const baseOpacity = 0.08;
              const opacity = (baseOpacity + strength * 0.45) * Math.min(a.opacity, b.opacity);
              
              if (opacity > 0.06) {
                a.connectTo(b);
                b.connectTo(a);
                
                // Connection line blends both node colors
                const mr = (a.color.r + b.color.r) / 2;
                const mg = (a.color.g + b.color.g) / 2;
                const mb = (a.color.b + b.color.b) / 2;
                
                ctx.beginPath();
                ctx.moveTo(a.x, a.y);
                ctx.lineTo(b.x, b.y);
                ctx.strokeStyle = `rgba(${mr}, ${mg}, ${mb}, ${opacity})`;
                ctx.lineWidth = 0.5 + strength * 1.5;
                ctx.stroke();
                
                if (Math.random() < 0.0005 * strength) {
                  signals.push(new Signal(a, b));
                }
              }
            }
          }
        }
        
        signals = signals.filter(signal => {
          const maxDist = Math.min(signal.nodeA.maxConnDist, signal.nodeB.maxConnDist);
          const dist = Math.hypot(
            signal.nodeA.x - signal.nodeB.x,
            signal.nodeA.y - signal.nodeB.y
          );
          if (dist > maxDist) return false;
          
          const alive = signal.update();
          if (alive) {
            const strength = 1 - (dist / maxDist);
            const opacity = strength * Math.min(signal.nodeA.opacity, signal.nodeB.opacity);
            signal.draw(opacity);
          }
          return alive;
        });
        
        nodes.forEach(node => node.draw());
        
        requestAnimationFrame(animate);
      }
      
      animate();
    </script>
  </body>
</html>