---
// Brain Week 2026 - Landing Page
---

<html lang="pl">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width" />
    <meta name="description" content="Brain Week 2026 - Uniwersytet w Białymstoku, 9-13 marca. Biologiczne i sztuczne sieci neuronowe." />
    <title>Brain Week 2026 | UwB</title>
  </head>
  <body>
    <!-- Network canvas -->
    <canvas id="network"></canvas>
    
    <!-- Brain image -->
    <div class="brain-container">
      <img src="/brain-week/brain-lateral.png" alt="" class="brain-image" />
    </div>
    
    <!-- Content -->
    <main>
      <h1>Brain Week</h1>
      <p class="year">2026</p>
      <p class="subtitle">Biologiczne i Sztuczne Sieci Neuronowe</p>
      <p class="dates">9–13 marca</p>
      <p class="location">Uniwersytet w Białymstoku</p>
      
      <div class="cta">
        <a href="#program" class="button">Program</a>
        <a href="#prelegenci" class="button button-secondary">Prelegenci</a>
      </div>
    </main>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html, body {
        height: 100%;
        overflow-x: hidden;
      }

      body {
        background: linear-gradient(180deg, 
          #0a0a0f 0%, 
          #0d0d1a 30%,
          #111128 60%,
          #0a0a0f 100%
        );
        background-attachment: fixed;
        color: #e2e8f0;
        font-family: 'Segoe UI', system-ui, sans-serif;
        min-height: 100vh;
        position: relative;
      }

      #network {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
      }

      .brain-container {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: min(75vw, 550px);
        z-index: 2;
        pointer-events: none;
        animation: brainFadeIn 3s ease-out forwards;
      }

      @keyframes brainFadeIn {
        0% {
          opacity: 0;
          filter: blur(15px);
        }
        100% {
          opacity: 1;
          filter: blur(0);
        }
      }

      .brain-image {
        width: 100%;
        height: auto;
        mix-blend-mode: screen;
        opacity: 0.2;
        filter: hue-rotate(240deg) saturate(0.7) brightness(1.2);
        mask-image: radial-gradient(ellipse 80% 80% at 50% 50%, black 30%, transparent 70%);
        -webkit-mask-image: radial-gradient(ellipse 80% 80% at 50% 50%, black 30%, transparent 70%);
      }

      main {
        position: relative;
        z-index: 3;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 2rem;
        text-align: center;
      }

      h1 {
        font-size: clamp(2.5rem, 8vw, 5rem);
        font-weight: 300;
        letter-spacing: 0.2em;
        text-transform: uppercase;
        background: linear-gradient(135deg, #e2e8f0 0%, #a78bfa 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        opacity: 0;
        animation: fadeUp 1.5s ease-out 0.8s forwards;
      }

      .year {
        font-size: clamp(3rem, 10vw, 6rem);
        font-weight: 100;
        color: #8b5cf6;
        letter-spacing: 0.4em;
        margin: -0.5rem 0 0.8rem;
        padding-left: 0.4em;
        opacity: 0;
        animation: fadeUp 1.5s ease-out 1s forwards;
      }

      .subtitle {
        font-size: 0.95rem;
        color: #ffffff;
        letter-spacing: 0.2em;
        margin-bottom: 1.5rem;
        opacity: 0;
        animation: fadeUp 1.5s ease-out 1.2s forwards;
      }

      .dates {
        font-size: 1.2rem;
        color: #94a3b8;
        letter-spacing: 0.2em;
        opacity: 0;
        animation: fadeUp 1.5s ease-out 1.4s forwards;
      }

      .location {
        font-size: 1rem;
        color: #64748b;
        letter-spacing: 0.1em;
        margin-bottom: 2.5rem;
        opacity: 0;
        animation: fadeUp 1.5s ease-out 1.5s forwards;
      }

      .cta {
        display: flex;
        gap: 1rem;
        justify-content: center;
        flex-wrap: wrap;
        opacity: 0;
        animation: fadeUp 1.5s ease-out 1.7s forwards;
      }

      @keyframes fadeUp {
        0% {
          opacity: 0;
          transform: translateY(20px);
        }
        100% {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .button {
        padding: 1rem 2.5rem;
        border-radius: 4px;
        text-decoration: none;
        font-size: 0.85rem;
        letter-spacing: 0.15em;
        text-transform: uppercase;
        transition: all 0.3s ease;
        background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
        color: white;
        border: 1px solid transparent;
      }

      .button:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 30px rgba(139, 92, 246, 0.3);
      }

      .button-secondary {
        background: transparent;
        border: 1px solid #8b5cf6;
        color: #a78bfa;
      }

      .button-secondary:hover {
        background: rgba(139, 92, 246, 0.1);
      }
    </style>

    <script>
      const canvas = document.getElementById('network');
      const ctx = canvas.getContext('2d');
      
      let centerX, centerY;
      
      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        centerX = canvas.width / 2;
        centerY = canvas.height / 2;
      }
      resize();
      window.addEventListener('resize', resize);
      
      // Pareto distribution
      function pareto(xMin, alpha) {
        const u = Math.random();
        return xMin / Math.pow(u, 1 / alpha);
      }
      
      // Node class
      class Node {
        constructor() {
          this.connectedNodes = new Set();
          this.spawn();
        }
        
        spawn() {
          this.x = Math.random() * canvas.width;
          this.y = Math.random() * canvas.height;
          
          this.radius = Math.random() * 1.5 + 1;
          this.baseOpacity = Math.random() * 0.3 + 0.5;
          this.opacity = 0;
          
          // Variable base speed - some slow, some fast, few very fast
          if (Math.random() < 0.05) {
            // 5% are super fast (3x-4x normal max)
            this.baseSpeed = 1.2 + Math.random() * 0.4;
          } else {
            this.baseSpeed = 0.05 + Math.random() * 0.35;
          }
          this.currentSpeed = this.baseSpeed;
          this.targetSpeed = this.baseSpeed;
          
          // Random initial direction
          const angle = Math.random() * Math.PI * 2;
          this.vx = Math.cos(angle) * this.currentSpeed;
          this.vy = Math.sin(angle) * this.currentSpeed;
          
          this.maxLife = Math.floor((5 + Math.random() * 15) * 60);
          this.life = this.maxLife;
          this.maxConnDist = Math.min(pareto(50, 1.5), 450);
          
          this.pulsePhase = Math.random() * Math.PI * 2;
          this.pulseSpeed = 0.015 + Math.random() * 0.01;
          
          this.seeksCenter = false;
          this.connectedNodes.clear();
        }
        
        connectTo(other) {
          this.connectedNodes.add(other);
          this.seeksCenter = true;
        }
        
        update(nodes) {
          // Find max speed among connected nodes
          if (this.connectedNodes.size > 0) {
            let maxSpeedInGraph = this.baseSpeed;
            
            for (const other of this.connectedNodes) {
              if (other.baseSpeed > maxSpeedInGraph) {
                maxSpeedInGraph = other.baseSpeed;
              }
            }
            
            this.targetSpeed = maxSpeedInGraph;
            // Smooth acceleration (derivative-based)
            this.currentSpeed += (this.targetSpeed - this.currentSpeed) * 0.02;
          }
          
          if (this.seeksCenter) {
            const dx = centerX - this.x;
            const dy = centerY - this.y;
            const dist = Math.hypot(dx, dy);
            
            if (dist > 5) {
              const targetVx = (dx / dist) * this.currentSpeed;
              const targetVy = (dy / dist) * this.currentSpeed;
              this.vx += (targetVx - this.vx) * 0.025;
              this.vy += (targetVy - this.vy) * 0.025;
            }
            
            if (dist < 80) {
              this.opacity = Math.max(this.opacity - 0.025, 0);
              if (this.opacity <= 0) {
                this.spawn();
                return;
              }
            }
          } else {
            for (const other of nodes) {
              if (other === this) continue;
              
              const dx = other.x - this.x;
              const dy = other.y - this.y;
              const dist = Math.hypot(dx, dy);
              
              if (dist < 120 && dist > 10) {
                const force = 0.00008 * (1 - dist / 120);
                this.vx += (dx / dist) * force;
                this.vy += (dy / dist) * force;
              }
              
              if (dist < 25 && dist > 0) {
                const repel = 0.0002 * (1 - dist / 25);
                this.vx -= (dx / dist) * repel;
                this.vy -= (dy / dist) * repel;
              }
            }
            
            const margin = 50;
            const pushStrength = 0.0004;
            if (this.x < margin) this.vx += pushStrength * (margin - this.x);
            if (this.x > canvas.width - margin) this.vx -= pushStrength * (this.x - (canvas.width - margin));
            if (this.y < margin) this.vy += pushStrength * (margin - this.y);
            if (this.y > canvas.height - margin) this.vy -= pushStrength * (this.y - (canvas.height - margin));
          }
          
          this.x += this.vx;
          this.y += this.vy;
          
          // Maintain current speed
          const speed = Math.hypot(this.vx, this.vy);
          if (speed > 0.01) {
            const targetMagnitude = this.seeksCenter ? this.currentSpeed : this.baseSpeed;
            this.vx = (this.vx / speed) * targetMagnitude;
            this.vy = (this.vy / speed) * targetMagnitude;
          }
          
          const driftAngle = Math.random() * Math.PI * 2;
          this.vx += Math.cos(driftAngle) * 0.001;
          this.vy += Math.sin(driftAngle) * 0.001;
          
          const fadeInEnd = this.maxLife * 0.9;
          const fadeOutStart = this.maxLife * 0.15;
          
          if (!this.seeksCenter || Math.hypot(centerX - this.x, centerY - this.y) >= 80) {
            if (this.life > fadeInEnd) {
              this.opacity = Math.min(this.opacity + 0.025, this.baseOpacity);
            } else if (this.life < fadeOutStart) {
              this.opacity = Math.max(this.opacity - 0.015, 0);
            }
          }
          
          this.pulsePhase += this.pulseSpeed;
          this.life--;
          
          if (this.life <= 0) {
            this.spawn();
          }
        }
        
        draw() {
          if (this.opacity < 0.01) return;
          
          const pulse = Math.sin(this.pulsePhase) * 0.15 + 0.9;
          const r = this.radius * pulse;
          
          ctx.beginPath();
          ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(180, 160, 255, ${this.opacity * pulse})`;
          ctx.fill();
          
          ctx.beginPath();
          ctx.arc(this.x, this.y, r * 3, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(139, 92, 246, ${this.opacity * 0.12})`;
          ctx.fill();
        }
      }
      
      class Signal {
        constructor(nodeA, nodeB) {
          this.nodeA = nodeA;
          this.nodeB = nodeB;
          this.pos = 0;
          this.speed = 0.004 + Math.random() * 0.006;
          this.direction = Math.random() > 0.5 ? 1 : -1;
          if (this.direction < 0) this.pos = 1;
        }
        
        update() {
          this.pos += this.speed * this.direction;
          return this.pos >= 0 && this.pos <= 1;
        }
        
        draw(opacity) {
          const x = this.nodeA.x + (this.nodeB.x - this.nodeA.x) * this.pos;
          const y = this.nodeA.y + (this.nodeB.y - this.nodeA.y) * this.pos;
          
          ctx.beginPath();
          ctx.arc(x, y, 2, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(220, 200, 255, ${opacity * 0.8})`;
          ctx.fill();
          
          ctx.beginPath();
          ctx.arc(x, y, 5, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(180, 160, 255, ${opacity * 0.25})`;
          ctx.fill();
        }
      }
      
      const area = window.innerWidth * window.innerHeight;
      const nodeCount = Math.floor(area / 8000);
      
      const nodes = [];
      for (let i = 0; i < nodeCount; i++) {
        nodes.push(new Node());
      }
      
      let signals = [];
      
      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        nodes.forEach(node => node.update(nodes));
        
        for (let i = 0; i < nodes.length; i++) {
          for (let j = i + 1; j < nodes.length; j++) {
            const a = nodes[i];
            const b = nodes[j];
            const dist = Math.hypot(a.x - b.x, a.y - b.y);
            
            const maxDist = Math.min(a.maxConnDist, b.maxConnDist);
            
            if (dist < maxDist) {
              const strength = 1 - (dist / maxDist);
              // Ensure long connections are still visible
              const baseOpacity = 0.08;
              const opacity = (baseOpacity + strength * 0.45) * Math.min(a.opacity, b.opacity);
              
              if (opacity > 0.06) {
                a.connectTo(b);
                b.connectTo(a);
                
                ctx.beginPath();
                ctx.moveTo(a.x, a.y);
                ctx.lineTo(b.x, b.y);
                ctx.strokeStyle = `rgba(139, 92, 246, ${opacity})`;
                ctx.lineWidth = 0.5 + strength * 1.5;
                ctx.stroke();
                
                if (Math.random() < 0.0005 * strength) {
                  signals.push(new Signal(a, b));
                }
              }
            }
          }
        }
        
        signals = signals.filter(signal => {
          const maxDist = Math.min(signal.nodeA.maxConnDist, signal.nodeB.maxConnDist);
          const dist = Math.hypot(
            signal.nodeA.x - signal.nodeB.x,
            signal.nodeA.y - signal.nodeB.y
          );
          if (dist > maxDist) return false;
          
          const alive = signal.update();
          if (alive) {
            const strength = 1 - (dist / maxDist);
            const opacity = strength * Math.min(signal.nodeA.opacity, signal.nodeB.opacity);
            signal.draw(opacity);
          }
          return alive;
        });
        
        nodes.forEach(node => node.draw());
        
        requestAnimationFrame(animate);
      }
      
      animate();
    </script>
  </body>
</html>